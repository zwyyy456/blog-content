---
title: "2712. 使所有字符相等的最小成本 (Medium)"
date: 2023-05-29T11:57:51+08:00
lastmod: 2023-05-29T11:57:51+08:00 #更新时间
authors: ["zwyyy456"] #作者
categories: ["leetcode"]
tags: ["greedy algorithm"]
description: "" #描述
weight: # 输入 1 可以顶置文章，用来给文章展示排序，不填就默认按时间排序
slug: ""
draft: false # 是否为草稿
comments: false #是否展示评论
showToc: true # 显示目录
TocOpen: true # 自动展开目录
hidemeta: false # 是否隐藏文章的元信息，如发布日期、作者等
disableShare: true # 底部不显示分享栏
showbreadcrumbs: false #顶部显示当前路径
---
## 问题描述
[2712. 使所有字符相等的最小成本 (Medium)](https://leetcode.cn/problems/minimum-cost-to-make-all-characters-equal/)
给你一个下标从 **0** 开始、长度为 `n` 的二进制字符串 `s` ，
你可以对其执行两种操作：

- 选中一个下标 `i` 并且反转从下标 `0` 到下标 `i`（包括下标 `
0` 和下标 `i` ）的所有字符，成本为 `i + 1` 。
- 选中一个下标 `i` 并且反转从下标 `i` 到下标 `n - 1`（包括下
标 `i` 和下标 `n - 1` ）的所有字符，成本为 `n - i` 。

返回使字符串内所有字符 **相等** 需要的 **最小成本** 。

**反转** 字符意味着：如果原来的值是 '0' ，则反转后值变为 '1'
，反之亦然。

**示例 1：**

```
输入：s = "0011"
输出：2
解释：执行第二种操作，选中下标 i = 2 ，可以得到 s = "0000" 
，成本为 2 。可以证明 2 是使所有字符相等的最小成本。

```

**示例 2：**

```
输入：s = "010101"
输出：9
解释：执行第一种操作，选中下标 i = 2 ，可以得到 s = "101101"
，成本为 3 。
执行第一种操作，选中下标 i = 1 ，可以得到 s = "011101" ，成
本为 2 。
执行第一种操作，选中下标 i = 0 ，可以得到 s = "111101" ，成
本为 1 。
执行第二种操作，选中下标 i = 4 ，可以得到 s = "111110" ，成
本为 2 。
执行第一种操作，选中下标 i = 5 ，可以得到 s = "111111" ，成
本为 1 。
使所有字符相等的总成本等于 9 。可以证明 9 是使所有字符相等的
最小成本。
```

**提示：**

- `1 <= s.length == n <= 10⁵`
- `s[i]` 为 `'0'` 或 `'1'`

## 解题思路
遍历字符串，当碰到 `s[i]` 与 `s[i + 1]` 不相等的情况时，我们需要翻转字符串，可以执行第一种或者第二种方案，执行成本较小的那个方案。

这样执行后，`s[i]` 左侧的字符，包括 `s[i]` 都是相同的。

## 代码
```cpp
class Solution {
public:
    long long minimumCost(string s) {
    	long long res = 0;
    	int n = s.size();
    	for (int i = 0; i < n - 1; ++i) {
    		if (s[i] != s[i + 1]) {
    			res += min(i + 1, n - i - 1);
    		}
    	}
        return res;
    }
};
```